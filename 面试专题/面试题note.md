 







# 一、JavaScript

## 1.数据类型

**基本数据类型**

- Undefined、Null、Number、String、Boolean、Symbol

**引用数据类型**

- Object、function

## 2.设计模式
+ 单例模式：一个构造函数一生只能new一个对象(应用场景：alert弹出框)
  ```js
  function Person(){
    this.name='rose'
  }
  var instance=null
  function single(){
    if(instance===null){
      instance==new Person()
    }
    return instance
  }
  var p1=new single()
  var p2=new single()  //p1==p2
  ```
  
+ 组合模式：把若干启动方式一样的构造函数放在一起，准备一个总开关，总开关启动，那些构造函数就都启动了(应用场景：轮播图)
  
  + 实现：需要一个承载所有构造函数的实例数组；需要一个方法向数组里面添加内容；需要一个方法将数组里面的内容都启动
  
+ 观察者模式(又称：发布/订阅模式)：当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动更新；解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题；

##  3.js 的事件循环

因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
染等。

事件循环就是主线程任务执行完成，然后去事件队列中查找，不论是微任务还是宏任务，把找到的任务拿到主执行栈里执行，这样循环查找执行的操作被称为EvnetLoop;

![事件循环机制](C:\Users\Administrator\Desktop\面试题1\事件循环机制.png)

## 4.宏任务和微任务

<img src="C:\Users\Administrator\Desktop\面试题1\宏任务.png" alt="宏任务" style="zoom:50%;" />

## 5.js为什么是单线程

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

## 6.递归
+ 即自己调用自己；递归函数：一个函数内部自己调用自己，循环往复
+ 需要有初始化，自增，执行代码，条件判断，不然就是一个没有尽头的递归函数，我们叫做死递归
```
function fn(){
  fn()
};
fn();
```
+ 斐波那契数列(兔子数列)的第n项,指的是这样一个数列：0、1、1、2、3、5、8、13、21、34
  ```
   function Fibonacci(n){
     if(n==1){
       return 0;
     }
     if(n==2){
       return 1;
     }
     return Fibonacci(n-1)+Fibonacci(n-2)
   }
  ```
## 7.闭包
+ 1.闭包是函数内部的函数。可以简单理解为在函数A内部直接或间接返回一个函数B，函数B内部使用函数A的私有变量，函数A外部有一个变量接收函数B。形成了一个不会销毁的空间
  ```js
  function a(){
      var n=100;
      return function b(){
          console.log(n)
      }
  }
  var res=a()
  res()
  ```
  
+ 2.特点：延长了变量的生命周期，可以访问函数内部私有变量，保护私有变量。

+ 3.致命的缺点：当前内存空间中有一个不会被销毁的空间，导致内存被占用，如果过多会导致内存溢出

## 8.js原型，原型链，有什么特点

- 每个对象都会在其内部初始化一个属性，就是`prototype`(原型)，当我们访问一个对象的属性时
- 如果这个对象内部不存在这个属性，那么他就会去`prototype`里找这个属性，这个`prototype`又会有自己的`prototype`，于是就这样一直找下去，直到返回一个uundefined，也就是我们平时所说的原型链的概念
- 当我们访问一个对象的属性或者方法的时候，会先去对象自身找这个属性或者方法,如果没有找到，则会去它的原型对象身上找,如果原型对象身上也没有找到，则会到原型对象的原型对象上去找，以此类推，找到则返回对应的值，如果直到原型对象为null任然没有找到则返回undefined。
- 在函数对象中存在原型对象prototype，在普通对象中没有`prototype`，但存在`__proto__`。或者说使用function定义的对象与使用new操作符生成的对象之间有一个重要的区别，这个区别就是function定义的对象有一个prototype属性，使用new生成的对象就没有这个prototype属性，存在`__proto__`。
- 关系：`instance.constructor.prototype = instance.__proto__`
- 特点：
  - `JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变
- 当我们需要一个属性的时，`Javascript`引擎会先看当前对象中是否有这个属性， 如果没有的
- 就会查找他的`Prototype`对象是否有这个属性，如此递推下去，一直检索到 `Object` 内建对象

## 9.闭包造成的内存泄露如何解决

- 在退出函数之前，将不使用的局部变量全部删除。可以使变量赋值为null
- 避免变量的循环赋值和引用。循环引用引起的内存泄漏，是因为IE 的bug，循环引用无法自动判断，所以通过拷贝值，把内外引用脱钩，这样就可回收。

## 10.ES6新增语法
+ 1.let和const用于声明变量。与var的区别：不允许重复声明，不会在预解析时解析，会被代码块限制作用域。let声明变量的值可以被改变，const声明变量的值不能被改变（const声明的是常量）。let声明时可以不赋值，const声明时必须赋值。
+ 2.箭头函数：函数可以简写成箭头函数。箭头函数内部没有this、this指向上下文；内部没有arguments；函数参数只有一个时，括号可以不写；函数只有一行代码时可以不写{}并且会自动return
+ 3.解构对象指快速从对象或数组中取出一个成员的方式。[]专门用于解构数组使用，{}专门用于解构对象使用。
+ 4.模板字符串：es6中可以使用返单引号``表示字符串。它的特点是可以换行书写，可以在字符串中直接拼接变量，用${}来书写变量的位置。
+ 5.展开运算符：es6中添加了一个...运算符，叫做展开运算符。它的作用是把数组或对象展开。合并数组，对象时可用。
+ 6.Arry.from:将类似数组转换成真正的数组。
+ 7.set:使用构造函数定义一个set类型，构造函数是一个数组。set类型里面的元素不允许重复。可以用于数组去重
+ 8.Map类型是一个数据集合，是一个类似于对象的集合。和new连用。它的特点是在Map中，key可以为任意数据类型。
+ 9.import/export语法：用于引入文件。


## 11.cookie/localstorage/sessionstorage
⒈localStorage长期存储数据，浏览器关闭数据后不丢失；

⒉sessionStorage数据在浏览器关闭后自动删除；

⒊cookie是网站为了标识用户身份而存储在用户本地终端（Client  Side）上的数据（通常经过加密）。cookie始终在同源的http请求中携带（即使不需要）都会在浏览器和服务器端间来回传递。session storage和local storage不会自动把数据发给服务器，仅在本地保存；

⒋存储大小：cookie数据大小不会超过4K，session storage和local storage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或者更多；

⒌有期时间：local storage存储持久数据，浏览器关闭后数据不丢失，除非自动删除数据。session storage数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭；

## 12.传输协议
+ http:超文本传输协议，信息是明文传输。用于前后端数据的沟通。默认使用80端口。
+ https：是具有安全性的SSL加密传输协议，简单来讲就是http的安全版。为浏览器和服务器之间的通信加密，确保数据传输安全。默认使用443端口。
+ 怎样配置一个网站，让它是https协议：1.购买、下载SSL证书 2.升级前做好网站备份 3.安装证书 
		http的缓存机制？有两个缓存机制： 
  + 强制缓存机制：简单理解为设置一个时间，浏览器在这个时间内都不会向服务器发送请求，而是使用缓存中的资源文件。当浏览器请求资源的时候会查看缓存中的资源是否存在并且确定该缓存的资源是否过了“保质期”，若没有超过保质期则将取得缓存中的资源进行下一步处理。
  + 协商缓存（对比缓存）：浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据
+ 请求步骤：建立连接，前端发送请求，后端返回响应，断开连接。
  + 建立连接是基于TCP/IP的三次挥手。目的是确保前后端可以正常通信
  + 前端发送请求是以请求报文的形式发送。请求报文中主要包含请求行、请求头、请求体。请求行是指请求方式。常见的请求方式有八种。其中GET和post是http请求中常用的两种方式。
  + 后端响应：每一个响应都是以响应报文的形式返回
  + 断开连接是基于TCP/IP协议四次挥手。目的是保证互相不进行通信
+ GET：倾向于向服务器获取数据，大小限制在2KB左右，可以直接在浏览器后面拼接，采用明文发送不是很安全，数据格式必须是URL编码格式,会被浏览器主动缓存
+ POST:倾向于向服务器传递数据，大小理论上没有限制，需要在请求体中发送，采用暗文发送相比起GET比较安全，数据格式理论上没有要求但要与请求头一致，不会别浏览器主动缓存，需要手动设置。
+ 响应状态码：响应报文中的一个信息，表示本次请求的状态。分为5类
  + 100-199:连接继续
  + 200-299：200标准成功：202服务器已接受请求但未处理，204服务器处理完成但没有返回实际内容
  + 300-399：重定向；301永久定向，302临时重定向，304缓存
  + 400-499：客户端错误；404请求地址有误，403权限不够查看、413传输数据量太大、405请求方法不支持
  + 500-599：服务端错误；502服务器过载、504防火墙超时

## 13.强，弱缓存

**强缓存**先在本地查找该资源，如果发现该资源，并且其他限制也没有问题(比如:缓存有效时间)，就命中强缓存，返回200，直接使用强缓存，并且不会发送请求到服务器

```
使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，
它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间
的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires
来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n
o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。
```

**弱缓存**在本地缓存中找到该资源，发送一个http请求到服务器，服务器判断这个资源没有被改动过，则返回304，让浏览器使用该资源。

```
使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。
如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。

服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，
这样会造成缓存命中的不准确。

因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。
```

**区别**

- 强缓存不发送请求，直接从缓存中取。
- 弱缓存需要发送一个请求，验证这个文件是否可以使用（有没有被改动过）
-  强缓存返回200(from cache),弱缓存返回304状态码



## 14.节流和防抖

+ 防抖是指事件触发后在规定时间内回调函数只执行一次，如果规定时间内又触发了该事件，则会重新开始计算时间。可以总结为延迟执行。原理是：通过定时器将回调函数进行延迟，如果在规定时间内继续回调，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。应用场景：搜索框，用户在不断输入值时，用防抖来节约请求资源。
+ 节流是当持续触发事件时，在规定时间内只能调用一次回调函数。如果规定时间内再次触发了该事件，则什么也不做，也不会重置定时器。应用场景：监听滚动事件，比如下滑页面出现回到顶部按钮；鼠标不停点击触发时；
+ 节流与防抖相比，防抖是将多次执行变成最后一次执行，节流是将多次执行变为规定时间内只执行一次，不会重置定时器。
+ 优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。
+ lodash  第三方库  底层原理都是定时器

<img src="C:\Users\Administrator\Desktop\面试题1\防抖.png" alt="防抖" style="zoom: 50%;" />

<img src="C:\Users\Administrator\Desktop\面试题1\防抖区别.png" alt="防抖区别" style="zoom:50%;" />



## 15.网络攻击
+ XSS攻击：跨站脚本攻击，web中主流的攻击方式，利用web漏洞，恶意程序为javascript。这类漏洞能使得攻击者嵌入恶意脚本代码到正常用户会访问到的界面中，当正常用户访问到该页面时，则会导致该恶意脚本的执行。
  + 解决方案：过滤和转义。将特殊的符号转义、替换。不然innerHTML-->innerText
+ CSRF攻击：跨站请求伪造.利用了web中用户身份验证的一个漏洞.解决：加token

##  16.XSS 攻击？如何防范 XSS 攻击？

```
XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

XSS 一般分为存储型、反射型和 DOM 型。

存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。

反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。

DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。

XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。

对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。

因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。

还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
```

## 17.三次握手四次挥手

**TCP连接的三次握手：**

要建立一条全双工的数据通道，首先确认通道双方的数据收发能力是必须的，而三次握手，做的正是这个校验的操作，这里以一个简单的图文描述下：

![TCP连接的三次握手和四次挥手1](https://res-static.hc-cdn.cn/fms/img/37471981d25de73a8e7b11d4b7cc5e3b1603447260101)

**第一次握手**：由客户端向服务端发起连接请求，服务端收到客户的请求，确认了客户端的消息发送是没有问题的。

**第二次握手**：由服务端向客户端发送可以建立连接的确认消息，客户端收到后，即可确认服务端的收发都是正常的。

**第三次握手**：由客户端向服务端发送确认消息，服务端收到后，即确认了客户端的接收能力是正常的，至此可以愉快的开始交流了。



**TCP连接的四次挥手：**

数据交互完毕，自然是要关闭通道，节省资源的，但关闭通道的前提是双方都要确认对方已经没有数据要发送了，所以就有了四次挥手的操作，同样，以图文描述（由于通道关闭可以是任何一方发起，这里把连接的两端都看成客户端）：

![TCP连接的三次握手和四次挥手2](https://res-static.hc-cdn.cn/fms/img/585e57f89b4b1c010810788e7ab406f91603447260101)

**第一次挥手**：由客户端1通知客户端2，己方已经没有消息要发送给客户端2了；

**第二次挥手**：由客户端2通知客户端1，已收到通知；

**第三次挥手**：由客户端2通知客户端1，己方已经没有消息要发送给客户端1了；

**第四次挥手**：由客户端1通知客户端2，已收到通知；

**总结：**

1、从三次握手和四次挥手来看，他们都是为了保证通道建立和断开的可靠及安全性，缺少任何一次，都会导致双方无法确认对方的状态，无法正确的开启和关闭连接；

2、四次挥手为什么不把第二次和第三次合并成一次，因为第二次是响应第一次挥手，第三次是客户端2通知客户端1，己方已经没有消息发送了，但是在第二次挥手和第三次挥手中间，客户端2还是可以向客户端1发送数据的，所以第二次和第三次无法合并。



## 18.回流与重绘

**回流必将引起重绘，重绘不一定会引起回流。**

在讨论回流与重绘之前，我们要知道：

1. 浏览器使用流式布局模型 (Flow Based Layout)。
2. 浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了`Render Tree`渲染树。
3. 有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
4. 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，table的计算需要不止一次的遍历，table是可以影响之前已经进入的DOM元素的显示的元素。即使一些小的变化和会导致table中所有其他节点回流。他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一。

**回流**

- 当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

  会导致回流的操作：

  - 盒模型相关的属性: `width`，`height`，`margin`，`display`，`border`等
  - 定位属性及浮动相关的属性: `top`,`position`,`float`等
  - 改变节点内部文字结构也会触发回流:`text-align`, `overflow`, `font-size`, `line-height`, `vertival-align`等

  - 页面首次渲染
  - 浏览器窗口大小发生改变
  - 元素尺寸或位置发生改变
  - 元素内容变化（文字数量或图片大小等等）
  - 元素字体大小变化
  - 添加或者删除**可见**的`DOM`元素
  - 激活`CSS`伪类（例如：`:hover`）
  - 查询某些属性或调用某些方法

**重绘**

- 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**性能影响**

**回流比重绘的代价要更高。**

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。

现代浏览器会对频繁的回流或重绘操作进行优化：

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

当你访问以下属性或方法时，浏览器会立刻清空队列：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `width`、`height`
- `getComputedStyle()`
- `getBoundingClientRect()`

因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

**如何避免**

### CSS

- 避免使用`table`布局。
- 尽可能在`DOM`树的最末端改变`class`。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
- 避免使用`CSS`表达式（例如：`calc()`）。

### JavaScript

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。




# 19.跨域

+ 同源策略:浏览器的安全策略、是为了保护本地数据不被JavaScript代码获取回来的数据污染
+ 浏览器具有同源策略，当请求的传输协议、域名、端口号有任意一个不同时，浏览器会认为你在请求别人的服务器，它会阻止，显示触发'同源策略'；同源策略也叫跨域请求；
+ 跨域问题的解决方案有：JSONP、CORS跨域、代理；
+ JSONP是利用script不受同源策略的影响来请求数据
+ CORS是让后端开启跨域资源共享来请求数据
+ 代理是我常用的一种解决跨域的方式；在浏览器同源设置一个代理服务器，把本该发送给目标服务器的请求发送给代理服务器，由代理服务器发送给目标服务器，目标服务器把响应返回给代理服务器，代理服务器把响应返回给浏览器
# 20.前段性能优化

> **加载优化**

- **减少HTTP请求**：尽量减少页面的请求数(**首次加载同时请求数不能超过4个**)，移动设备浏览器同时响应请求为4个请求(**`Android`支持4个，`iOS5+`支持6个**)
  - 合并CSS和JS
  - 使用CSS精灵图
- **缓存资源**：使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存，并且尽量使用长缓存(**使用时间戳更新缓存**)
  - 缓存一切可缓存的资源
  - 使用长缓存
  - 使用外联的样式和脚本
- **压缩代码**：减少资源大小可加快网页显示速度，对代码进行压缩，并在服务器端设置`GZip`
  - 压缩代码(多余的缩进、空格和换行符)
  - 启用Gzip
- **无阻塞**：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部并使用`link`方式引入，脚本放在尾部并使用异步方式加载
- **首屏加载**：首屏快速显示可大大提升用户对页面速度的感知，应尽量针对首屏的快速显示做优化
- **按需加载**：将不影响首屏的资源和当前屏幕不用的资源放到用户需要时才加载，可大大提升显示速度和降低总体流量(**按需加载会导致大量重绘，影响渲染性能**)
  - 懒加载
  - 滚屏加载
  - Media Query加载
- **预加载**：大型资源页面可使用`Loading`，资源加载完成后再显示页面，但加载时间过长，会造成用户流失
  - 可感知Loading：进入页面时`Loading`
  - 不可感知Loading：提前加载下一页
- **压缩图像**：使用图像时选择最合适的格式和大小，然后使用工具压缩，同时在代码中用`srcset`来按需显示(**过度压缩图像大小影响图像显示效果**)
  - 使用[TinyJpg](https://tinyjpg.com/)和[TinyPng](https://tinypng.com/)压缩图像
  - 使用CSS3、SVG、IconFont代替图像
  - 使用img的srcset按需加载图像
  - 选择合适的图像：`webp`优于`jpg`，`png8`优于`gif`
  - 选择合适的大小：首次加载不大于`1014kb`、不宽于`640px`
  - PS切图时D端图像保存质量为80，M端图像保存质量为60
- **减少Cookie**：`Cookie`会影响加载速度，静态资源域名不使用`Cookie`
- **避免重定向**：重定向会影响加载速度，在服务器正确设置避免重定向
- **异步加载第三方资源**：第三方资源不可控会影响页面的加载和显示，要异步加载第三方资源

> **执行优化**

- **CSS写在头部，JS写在尾部并异步**
- **避免img、iframe等的src为空**：空`src`会重新加载当前页面，影响速度和效率
- **尽量避免重置图像大小**：多次重置图像大小会引发图像的多次重绘，影响性能
- **图像尽量避免使用DataURL**：`DataURL`图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长

> **渲染优化**

- **设置viewport**：HTML的`viewport`可加速页面的渲染

  ```
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1">
  ```

- **减少DOM节点**：DOM节点太多影响页面的渲染，尽量减少DOM节点

- **优化动画**

  - 尽量使用CSS3动画
  - 合理使用requestAnimationFrame动画代替setTimeout
  - 适当使用Canvas动画：5个元素以内使用`CSS动画`，5个元素以上使用`Canvas动画`，`iOS8+`可使用`WebGL动画`

- **优化高频事件**：`scroll`、`touchmove`等事件可导致多次渲染

  - 函数节流
  - 函数防抖
  - 使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染
  - 增加响应变化的时间间隔：减少重绘次数

- **GPU加速**：使用某些HTML5标签和CSS3属性会触发`GPU渲染`，请合理使用(**过渡使用会引发手机耗电量增加**)

  - HTML标签：`video`、`canvas`、`webgl`
  - CSS属性：`opacity`、`transform`、`transition`

> **样式优化**

- **避免在HTML中书写style**
- **避免CSS表达式**：CSS表达式的执行需跳出CSS树的渲染
- **移除CSS空规则**：CSS空规则增加了css文件的大小，影响CSS树的执行
- **正确使用display**：`display`会影响页面的渲染
  - `display:inline`后不应该再使用`float`、`margin`、`padding`、`width`和`height`
  - `display:inline-block`后不应该再使用`float`
  - `display:block`后不应该再使用`vertical-align`
  - `display:table-*`后不应该再使用`float`和`margin`
- **不滥用float**：`float`在渲染时计算量比较大，尽量减少使用
- **不滥用Web字体**：Web字体需要下载、解析、重绘当前页面，尽量减少使用
- **不声明过多的font-size**：过多的`font-size`影响CSS树的效率
- **值为0时不需要任何单位**：为了浏览器的兼容性和性能，值为`0`时不要带单位
- **标准化各种浏览器前缀**
  - 无前缀属性应放在最后
  - CSS动画属性只用-webkit-、无前缀两种
  - 其它前缀为-webkit-、-moz-、-ms-、无前缀四种：`Opera`改用`blink`内核，`-o-`已淘汰
- **避免让选择符看起来像正则表达式**：高级选择符执行耗时长且不易读懂，避免使用

> **脚本优化**

- **减少重绘和回流**
  - 避免不必要的DOM操作
  - 避免使用document.write
  - 减少drawImage
  - 尽量改变class而不是style，使用classList代替className
- **缓存DOM选择与计算**：每次DOM选择都要计算和缓存
- **缓存.length的值**：每次`.length`计算用一个变量保存值
- **尽量使用事件代理**：避免批量绑定事件
- **尽量使用id选择器**：`id`选择器选择元素是最快的
- **touch事件优化**：使用`tap`(`touchstart`和`touchend`)代替`click`(**注意`touch`响应过快，易引发误操作**)

# 21.前端调试代码

- 使用console.log(推荐)
- 使用alert()(不推荐)
- 使用debuggerr（就是我们常说的打断点） （推荐）

# 22.Vue和react的区别

- vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定。 
- vue的语法较为简单，适用于小型项目创建，而react更适用于Web端和原生App的开发，侧重于大型应用。 
- vue拥有更快的渲染速度和更小的体积，react则拥有更大的生态圈，可以带来更多的工具支持。 
- 模板渲染方式的不同。在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。 
- 在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。 
- 说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。 
- 框架本质不同。Vue本质是MVVM框架，由MVC发展而来；React是前端组件化框架，由后端组件化发展而来。
- 监听数据变化的实现原理不同。Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。 

# 23.vue为什么不能兼容ie6

- 因为**Object.defineProperty** 这个api在ie6不支持这个api，只要ie9以上才有

# 24.hash和history路由

- Hash路由，是使用 location.href 锚点技术来实现跳转 
- url中有一个 #，部署上线没有任何问题
- History模式，是使用 history.pushState 实现跳转 
- url中没有#，但是部署上线会出现404，要求后端进行Nginx/Apache做重定向处理

# 25.事件冒泡  

- 事件冒泡是由IE开发团队提出来的，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播。 

# 26.阻止冒泡

- window.event.cancelBubble = true 
- 在w3c模型中你必须调用事件的stopPropagation()方法 e.stopPropagation() 

# 27.事件委托

- 事件捕获是由Netscape Communicator团队提出来的，是先由最上一级的节点先接收事件，然后向下传播到具体的节点。 

attachEvent()采用冒泡方式，而addEventListener()可以采用冒泡或事件捕获方式。 

# 28.DOM 0级和2级

##### 0级事件

- 分为2个：一是在标签内写onclick事件
- 二是在JS写onlicke=function（）{}函数

##### 2级事件

- 监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()。 
- 只有2级DOM包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段 

# 29.跨域与CORS

同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者
script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

#### 什么是跨域？

- '协议://域名:端口' 有任何一个不同都是跨域。 

  ```html
  //都是跨域
  http://baidu.com   https://baidu.com
  http://m.baidu.com   http://baidu.com
  http://10.192.160.20:8080    http://10.192.160.20:8081
  http://localhost:8080   http://127.0.0.1:8080
  ```

#### 什么是CORS？

- 浏览器同源策略，是一种安全机制。它的特点是，阻止Ajax进行跨域（非同源）下的数据请求。 
- CORS只在**浏览器**中才起作用，在Node服务器上使用ajax工具跨域请求，是没有任何问题的。 
- 总结：只有在浏览器中，CORS同源策略才会阻止ajax的跨域请求 。



#### 如何解决CORS阻止ajax跨域请求的问题？（常用有三种）

- JSONP 只能解决GET请求的跨域请求问题 
- CORS  在后端添加headers以允许被非同源访问 
- 代理：前端代理、后端Nginx/Apache代理 



#### 前端代理解决"CORS阻止ajax跨域请求"的机制是怎样的呢？

- 让前端业务在本地服务器(localhost:8080)运行，访问本地服务器(localhost:8080)调接口，如此就不跨域。
- 本地服务器做了代理，当收到前端业务请求时，进行代理转发，相当于是node服务向远程后台服务器发起请求数据。
- node服务向远程发起请求，跨域了，但是node环境中没有CORS同源策略。因此不跨域

# 30.es5

- **严格模式 use strict** 

- 1：消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。

  2：消除代码运行的一些不安全之处，保证代码运行的安全。

  3：提高编译器效率，增加运行速度。

  4：为未来新版本的Javascript做好铺垫。

- **ES5新增JSON对象方法**

- JSON.parse：将一个JSON格式的字符串转换成对象。 

- JSON.stringify：将对象转换成JSON格式的字符串。 

- **Object扩展**

- Object.create(prototype, [descriptors])

- 作用: 以指定对象为原型创建新的对象

- 为新的对象指定新的属性, 并对属性进行描述

- Object.defineProperties(object, descriptors)

- get ：用来获取当前属性值得回调函数

- set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值

- 存取器属性：setter,getter一个用来存值，一个用来取值

- **Array扩展**

- **Function扩展**

- Function.prototype.bind(obj) :

- 作用: 将函数内的this绑定为obj, 并将函数返回

- 都能指定函数中的this

- call()/apply()是立即调用函数

- bind()是将函数返回

 

# 31.为什么要使用图片懒加载

对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。 

##### 原理

- 将资源路径赋值到img标签的data-xx属性中，而不是src属性
- 获取img节点距离浏览器顶部的距离，如果小于或等于浏览器窗口的可视高度，那么就将data-xx的值赋值到src里去

# 32.React如何实现图片懒加载

[Lazyload](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsbfkcel%2Flazyload) 是一个文件大小仅4kb的图片懒加载组件（不依赖其它第三方库），组件会根据用户当前浏览的区域去自动加载对应的图片（用户还没有浏览的区域图片则不会进行加载）。

[Lazyload](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsbfkcel%2Flazyload) 允许图片加载之前，指定一张相对较小的封面图。组件会优先加载封面图片，以优化用户浏览感受。当原图加载完成之后则会覆盖封面图片。

# 33.谷歌浏览器

- Chrome每个模块及其主要功能为：

  Element ： 用于查看和编辑当前页面中的 HTML 和 CSS 元素。

  Network ：用于查看 HTTP 请求的详细信息，如请求头、响应头及返回内容等。

  Source ：用于查看和调试当前页面所加载的脚本的源文件。

  TimeLine ： 用于查看脚本的执行时间、页面元素渲染时间等信息。

  Profiles ：用于查看 CPU 执行时间与内存占用等信息。

  Resource ：用于查看当前页面所请求的资源文件，如 HTML，CSS 样式文件等。

  Audits ：用于优化前端页面，加速网页加载速度等。

  Console ：用于显示脚本中所输出的调试信息，或运行测试脚本等。

## promise
+ 回调地狱是：把函数A当做参数传递到函数B中，在函数B中以形参的方式进行调用；当回调函数嵌套过多时会出现回调地狱，即没有可维护性和可读性代码；
+ promise：ES6中有个内置构造函数叫promise，主要用于异步计算，每个异步事件在执行时都有三个状态：执行中(pending)、成功(resolve)、失败(rejected)；是解决回调地狱的方案之一，把回调地狱写的优雅的方案之一；
## async和await
+ async和await是promise的语法糖
+ async为异步的，await为等待
+ async是声明某个函数式异步的，await是等待某个操作的完成
+ 语法上强制规定await只能出现在async函数中
## 原型和原型链
+ 原型对象Prototype:每个构造函数天生自带一个成员叫做prototype；构造函数中、公共的方法存放在原型对象上；它的作用是共享方法；
+ 对象原型_proto_：每个对象天生自带一个成员叫_proto_；它指向构造函数的prototype原型对象；之所以实例对象可以使用构造函数prototype原型对象的属性和方法，就是因为有_proto_原型的存在；
+ 实例对象的_proto_和构造函数的prototype指向的是同一个对象空间，是等价的；
+ 原型链：访问一个对象成员时，如果自己身上没有就会去_proto_中找，如果没有就再去构造函数的prototype的_proto_里找，直到找到object、prototype里没有，返回undefine；这样一层层的往上找会形成一个链式结构、称为原型链

## MVP、 MVC、MVVM
+ mvc:由model模型、view视图、controller控制器组成。是软件架构中最常见的一种框架。它的工作原理是当用户触发事件时，view层会发送指令到controller层，controller层去通知model更新数据，model更新完数据后直接显示在view上。缺点：耦合度太高
+ mvp:作为mvc的演化，解决了不少mvc的缺点。mvp模式将cotroller改成了presenter，同时改变通信的方向。view跟model不再发生关系，取而代之的是presenter充当了桥梁的作用。用户触发事件，view发送指令到presenter,presenter通知model更新数据，model更新完数据发送给persenter，presenter再将数据显示在view上。
+ mvvm：将presenter换成了viewmodel层。viewmdel(就是与界面(view)对应的Model ) 和view是数据双向绑定的关系。view变动，viewmodel也会跟着变化.更新viewmodel层数据时，view也会相应变化。
+ 查看文档解释：http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html

## BSR、SSR
+ BSR客户端端渲染(前后端分离)：视图和数据的组装是在客户端完成的
+ SSR 服务器渲染(前后端不分离)：视图和数据的组装是在服务器端完成
+ BSR的优缺点：前后端分离，代码更容易维护；数据化应用，交互更加丰富；对于前端工程师而言价值更高；但是它的SEO有严重的劣势；在TOB的产品上应用更加广泛
+ SSR的优缺点：前后端不分离，对后端要求更高；有利于SEO优化；对客户端压力比较小，服务器压力大；在TOC产品上应用比较广泛。
+ 原理：在node环境下运行的，用的是第三方的库，把动态组件转化为HTML
## SEO优化
+ 搜索引擎优化，让更多用户找到你

+ 优化的原则是：尽量减少js、css功能，尽肯能多地使用静态html。
  + 使用h1-h6标签，尽量减少使用div,使用htm5语义化标签，加上title属性，给图片加上alt属性
+ 脚手架环境中：能尽量写死的就尽量写死，meta标签中添加title属性，给图片加alt属性，减少使用div

## 深浅拷贝
+ 浅复制：浅复制一般用于基本数据类型。基本数据类型存在栈中，直接复制即可。

  ‘=’直接赋值、Object.assign()【Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。】

+ 深复制：对象层级过深时，无法自动更新，需要用到深复制。就是把数据粉碎再组装。原理：对象的地址在栈里面，内容在堆里面。直接复制时只是复制它的地址，但指向的是同一个堆。深复制不仅能复制地址还能复制堆。JSON.parse(JSON.stringify(state.goodObj)) 、递归拷贝、使用Object.create()方法、

## ajax
+ AJAX是异步的javascript和XML。是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量的数据交换，AJAX可以使网页实现异步更新。
+ 优点：异步模式、提升了用户体验；优化了浏览器和服务器之间的数据传输、减少不必要的数据往返；在客户端运行、减少了服务器的负载；
+ 特点：动态不刷新(局部更新)
+ 原生js，ajax请求步骤：
  + 1.创建ajax对象：new XMLHttpRequest()
  + 2.配置本次请求信息：ajax对象.open(请求方式，请求地址，是否异步)
  + 3.发送请求： ajax对象.send()
  + 4.接收后端响应： ajax对象.onload=function(){} 
+ ajax状态码：ajax对象.readystate
  + 0：表示创建一个ajax对象成功
  + 1：表示配置信息成功
  + 2：响应体已经回到浏览器，但不能是使用
  + 3：浏览器正在解析响应报文
  + 4：浏览器把响应体分离成功，可以正常使用
## axios
+ axios是用于发送和接收请求。一般我工作中会对axios进行二次封装；封装出一个api.js文件，这个文件里可以放不同请求，专门用于调接口；再通过axios去处理发送接收请求等。受同源策略的影响，需要通过vue.config.js进行代理。
+ 文件的配置分三个部分：
  + 1.请求配置信息： baseURL等相关配置
  + 2.请求拦截器：指的是请求被发出去之前做一些事，通常是加上token进行鉴权
  + 3.响应拦截器：在响应数据回来之前做一些事儿 ，通常根据http状态码判断请求是否成功，如果不成功要提示用户 ，根据业务状态码对数据进行过滤


# ajax和axios的区别

**1.区别**
axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。
简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。
axios是ajax ajax不止axios。

```js
axios({
    url: '/getUsers',
    method: 'get',
    responseType: 'json', // 默认的
    data: {
        //'a': 1,
        //'b': 2,
    }
}).then(function (response) {
    console.log(response);
    console.log(response.data);
}).catch(function (error) {
    console.log(error);
}）
```

```js
$.ajax({
    url: '/getUsers',
    type: 'get',
    dataType: 'json',
    data: {
        //'a': 1,
        //'b': 2,
    },
    success: function (response) {
        console.log(response)；
    }
})
```

2.优缺点：
ajax：
本身是针对MVC的编程,不符合现在前端MVVM的浪潮
基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案
JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务
axios：
从 node.js 创建 http 请求
支持 Promise API
客户端支持防止CSRF
提供了一些并发请求的接口（重要，方便了很多的操作）


## es5的严格模式
+ 对开发时的一些内容做了修改
+ 严格模式的开启：'use strict'
+ 规则：声明变量前必须有var关键字，函数的形参不可以重复，声明式函数调用时函数内部没有this，全局声明式函数调用时，函数内部的this指的是window，事件函数里面的this指向事件源。

## this指向
+ 每个函数的内部都有一个this关键字，this只与函数的调用方式有关。
+ 全局定义函数this指向window
+ 对象内部this指向调用者
+ 定时器this指向window
+ 事件处理函数this指向事件源
+ 自调用函数this指向window

## 数组常用的方法：
+ 1、push:在数组末尾添加一个元素；返回值是数组长度
+ 2、pop:删除数组末尾的一个元素；返回值是被删除的那个元素
+ 3、unshift:在数组前面添加一个元素；返回值是数组的长度
+ 4、shift:删除数组前面一个元素；返回值是被删除的那个元素
+ 5、splice:按照索引截取数组中的某些内容；返回值是被删除的元素集合
+ 6、reverse:用来翻转数组；返回值是 原 数组
+ 7、sort:排序；按照字符编码排序
+ 8、concat:拼接数组；不改变原数组、返回 新 数组
+ 9、join:把数组里面的每一个数据拼接起来变成字符串；返回 新 数组
+ 10、index of:用来找到数组中某一项的索引；返回值：索引、找不到返回-1
+ 11、lastIndex of:用来找到数组中某一项的索引、从后面开始找；返回值：索引、找不到返回-1
+ 12、forEach:遍历数组；语法：数组.forEach(function(item、index){})
+ 13、map:遍历数组、可以对数组中某一项进行操作，返回新数组；
+ 14、filter:遍历、筛选数组；把原始数组中满足条件的筛选出来，返回一个新数组；
+ 15、Sort:数组排序；升序：return a-b、降序：return b-a;返回值是排序好的数组
+ 16、Array from:将类数组转成真正的数组
+ 冒泡排序：先遍历数组、两两进行比较、若前一个比有一个大、那就把两个数据换个位置、遍历完成一遍后、最后一个数字就是最大那个；然后进行第二遍遍历、按之前规则，第二大数字就会跑到倒数第二个位置，以此类推，最后按从小到大排序
  ```js
   for(var j=0;j<arr.length;j++){
     for(var i=0;i<arr.length-1-j;i++){
       if(arr[i]>arr[i+1]){
         var temp=arr[i]
         arr[i]=arr[i+1]
         arr[i+1]=temp
       }
     }
   }
  ```
+ 选择排序：先假定数组中第0个就是最小数字索引，遍历数组、只要有一个数字比我小、就替换之前记录的索引、直到数组遍历结束后、找到最小的那个索引位置换到第0个位置；再来第二遍，假设第一个是最小数字的索引、再遍历一遍数组、找到那个比我小的索引、以此类推把数组排序好；
    ```js
      for(var j=0;j<arr.length-1;j++){
        var minIndex=j
        for(var i=j+1;i<arr.length;i++){
          if(arr[i]<arr[minIndex]){
             minIndex=i
          }
        }
        if(minIndex!=j){
          var temp=arr[minIndex];
          arr[minIndex]=arr[i];
          arr[j]=temp;
        }
      }
    ```
## 数组去重
+ 1.ES6中set方法去重；set里面的元素不允许重复；

  var arr=[1,2,3,1,2,3,4,5]   console.log(Array.from(new Set(arr)))  或者  console.log([...new Set(arr)])

+ 2.for循环嵌套for循环，通过splice去重
    ```js
     var arr=[1,2,4,3,3]
     for(var i=0;i<arr.length;i++){
       for(var j=i+1;i<arr.length;j--){
         if(arr[i]==arr[j]){
           arr.splice(j,1)
           j--
         }
       }
     }
    ```
    
+ 3. indexof去重
   ```js
      var arr=[1,2,4,3,3]
      var arrsy=[]
      for(var i=0;i<arr.length;i++){
         if(arrsy.indexof(arr[i])===-1){
           arrsy.push(arr[i])
         }
      }
   ```
## 字符串常用的方法
+ charAt(索引)：找到字符串中指定索引位置并返回
+ charCodeAt(索引)：返回对应的索引unicode编码
+ indexOf(字符)：按照字符找到对应的索引
+ lastindexOf(字符)：从后面开始找
+ subString(起索引，终索引)：截取字符串;包前不包后；第二个参数没有表示截取到末尾
+ subStr(从哪个索引开始，截取几个)
+ slice:与subString类似
+ repeat:重复字符串，返回新的字符串
+ fromcharcode():根据传入的编码，变成编码对应的字符
+ toLowerCase、toUpperCase:变大小写
+ split:字符串转数组
+ trim:去除首尾空格
+ replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
## undefine和null区别
+ 类型不一样：undefined是undefined 、null是object
+ 转化为值时不一样：undefined为NaN ,null为0 
+   console.log(null==undefined)//true
    console.log(null===undefined)//false
## 阻塞和非阻塞
+ 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回
+ 非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。


## window和document
+ window：是浏览器内置对象，包含操作浏览器的方法；可以获取浏览器的相关信息如：窗口位置、确定窗口大小、弹出对话框等等
+ document对象：是浏览器内置对象，存储着用来操作元素的方法。
## JS哪些操作会造成内存泄露
  + 意外的全局变量引起的内存泄露
  + 闭包引起的内存泄露
  + 没有清理的DOM元素引用
  + 被遗忘的定时器或者回调
  + 子元素存在引起的内存泄露

## 从输入url到页面加载完成发生了什么？
  + 1.浏览器的地址栏输入URL并按下回车
  + 2.浏览器查找当前URL的DNS缓存记录
  + 3.DNS解析URL对应的IP
  + 4.根据IP建立TCP连接
  + 5.HTTP发起请求
  + 6.服务器处理请求，浏览器接收HTTP响应
  + 7.渲染页面，构建DOM树
  + 8.关闭TCP连接

## 模块化：
+ ES6模块化：引入的外链式里使用了大量全局变量，可能会与自己写的变量冲突；希望可以引入，运行完了不要污染我的全局环境；import/export语法
+ CommenJs:node应用由模块组成，采用CommenJs模块规范；每个文件就是一个模块，拥有自己独立的作用域、变量、以及方法等，对其他的模块不可见。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性(module.exports)是对外的接口。加载某个模块其实是加载module.exports属性。**require**方法用于加载模块。
+ CommonJs与ES6区别：前者支持动态导入、后者不支持；前者是同步导入、后者是异步导入；前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化

## call, apply, bind：
+ 共同点：都可以改变this指向

+ 区别：传参方式不同；除第一个参数以外(要改变的this指向)，call可以接收一个参数列表、apply只能接收一个数组；bind其他两个方法作用也是一致的，只是该方法会返回一个函数

+ call 与 apply 的相同点：

  - 方法的含义是一样的，即方法功能是一样的；
  - 第一个参数的作用是一样的；

  call 与 apply 的不同点：两者传入的列表形式不一样

  - call可以传入多个参数；

  - apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入

    存在的意义：实现（多重）继承

## 为什么 0.1 + 0.2 != 0.3
+ 因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。
+ 原生解决办法:parseFloat((0.1 + 0.2).toFixed(10))
# webpack

# 看法

```
我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源
数。

我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。

Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。

Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。

Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。

loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。

插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。

使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。
```



## 作用：
+ 是当下前端工程化环境中使用最为广泛的构建工具.它的作用是把比较新的前端技术和文件模块编译成浏览器能够识别并尽可能兼容主流浏览器的代码，它就是一个打包器；
## 配置文件：(webpack.config.js/react.config.js/vue.config.js)
+ 项目的入口和出口都在这里运行；前端项目都运行在node.js环境中，这个配置文件是项目运行或打包时执行的；
+ 使用CommonJS模块化语法
## webpack-dev-serve:
+ 它是使用express编写的用于创建本地node服务的第三方包。一个小型的node.js Express服务器。简单来说就是一个小型的静态文件服务器
+ 它可以在pakege.json中更改命令行开启；
+ 它可以在react.config.js中添加devServer对象进行配置：端口号、指定本地服务的静态资源目录、自动打开浏览器、热更新等
## plugins
+ 用于把打包后的js/css等资源，自动插入到public/index.html中。
## clean-webpack-plugin
+ 在每次执行npm run build时，自动帮我们清理dist
## loaders:
+ webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。指在main.js中可以引入其他文件。比如aseet/css/common.css通过loader与public/index.html关联。
## HMR(Hot Module Replacement):模块热替换(热更新)
## babel.js
+ 把ES6语法转化成主流浏览器兼容的代码
## ESlint:检测JS语法规范
## 区分开发环境和生产环境 
+ cross-env:在node.js环境进程中添加环境变量
+ package.json中配置
+ react.config.json中：判断进程的环境是生产环境还是开发环境，生产环境和开发环境执行的代码不同
## resolve:
+ 1.定义绝对路径@：通过alias; 2.定义文件后缀名省略：extensions

## 区分开发环境和生产环境

开发环境的需求：

　　　　模块热更新  （本地开启服务，实时更新）
　　　　sourceMap    (方便打包调试)
　　　　接口代理　    (配置proxyTable解决开发环境中的跨域问题)

　　　　代码规范检查 (代码规范检查工具)

　　生产环境的需求：

　　　　提取公共代码　 　　    
　　　　压缩混淆(压缩混淆代码，清除代码空格，注释等信息使其变得难以阅读)
　　　　文件压缩/base64编码(压缩代码，减少线上环境文件包的大小)
　　　　去除无用的代码

 

　　开发环境和生产环境的共同需求：

　　　　同样的入口
　　　　同样的代码处理(loader处理)
　　　　同样的解析配置



webpack.base.conf.js：webpack的开发环境和生产环境的共有配置(开发环境和生产环境都是需要执行的配置)

webpack.dev.conf.js：webpack的开发环境的特有配置(只在开发环境中执行，生产环境中不执行)

webpack.prod.conf.js：webpack的生产环境的特有配置(只在生产环境中执行，开发环境中不执行)


# 二、HTML、CSS

## CSS垂直水平居中

**根据绝对定位absolute+margin实现水平居中**  给父元素一个相对定位relative，利用绝对定位absolute，配合margin：auto自动计算外边距（position: absolute; top: 0;right: 0; bottom: 0; left: 0;margin: auto;）。相对于相对应于relative的绝对定位absolute，需要定宽。relative只是为了给子元素定位用的

**使用absolute绝对定位+translate 移动转换，实现水平垂直居中**   使用百分比来绝对定位一个元素，并配合使用translate，将元素移动定位居中（position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)）。

**利用table布局，默认垂直居中（vertical-align:middle）** 如果不是table布局的话可以：**仿table（display：table-cell）**,一样使用vertical-align:middle实现居中对齐

**flex布局**  父元素使用display：flex,设置其属性justify-content.align-items都为center(display: flex; justify-content: center; align-items: center),实现水平居中

**flex布局+margin**  父元素使用flex布局（display：flex）,子元素使用margin：auto

## 样式穿透

1. ( >>> 只作用于css
2. ::v-deep 只作用于sass
3. /deep/ 只作用于less

## BFC
+ 块级格式化上下文
+ BFC是一块独立的布局环境，保护其中内部元素不受外部影响，也不影响外部。
+ BFC的应用：自适应两栏布局、清除内部浮动、防止margin上下重叠
+ 触发BFC的元素或属性：float属性不为none；position为absolute或fixed；display为inline-block；overflow不为visible
## 浏览器渲染页面的过程
+ 1.处理HTML并构建DOM树
+ 2.处理css构建cssOM树
+ 3.将DOM与CSSOM合并成一个渲染树
+ 4.根据渲染树来布局，计算每个节点的位置
+ 5.调用 GPU 绘制，合成图层，显示在屏幕上
## 回流、重绘
+ 回流： 根据渲染树来布局，计算每个节点的位置，进行回流
+ 重绘： 根据渲染树以及回流得到的几何信息，得到节点的几何像素
+ 回流一定会触发重绘、但重绘不一定会回流
## 伪类的用法::before    ::after
+ 之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素
+ 伪元素:before和:after添加的内容默认是inline元素；这两个伪元素的content属性表示伪元素的内容，设置：before和：after时必须设置其content属性，否则伪元素就不起作用。
## css有哪些选择器
+ css3新增的选择器：
+ 1.属性选择器->E[attr]
+ 2.伪类选择器->X:first-child、X:last-child、X:nth-child(n)
+ 3.目标伪类选择器->E:target
+ 4.层级选择器->E>F、E+F、E~F
+ 小结：常用的选择器有标签选择器、id选择器、类别选择器等；css3新增的选择器有属性选择器、伪类选择器、目标伪类选择器、层级选择器等
## 垂直居中的方法
+ margin:0 auto;
+ position:fixed;left:50%;top:50%;margin-top:-高的一半；margin-left：-宽的一半
## px、em、rem
+ px: PC端的尺寸单位；像素、绝对单位
+ em: 相对于最近父元素的倍数
+ rem：移动端尺寸单位；根元素倍数；相对于根元素html的font-size计算值的大小。简单理解为屏幕宽度百分比
## xhtml和html区别
+ html（超文本标记语言）：以一种语法较为松散、不严格的web语言
+ XHTML（可扩展的超文本标记语言）:作用与HTML类似，是为了解决HTML的混乱问题而生，语法更加严格
## link 和@input的区别
+ 来源的区别：link属于XHTML标签，而@import属性css
+ 加载顺序的区别：页面加载时，link会被同时加载，而@import在页面加载完成后才会加载引用的CSS
+ 兼容性的差别：@import属于css2.1版本,只有在IE5以上才可以被识别，而link是HTML标签，不存在浏览器兼容性问题。
+ 使用dom控制样式时的差别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的.
## 浏览器内核(现代4大内核)
+ 1.Trident:IE （-ms-）
+ 2.Gecko: Mozilla(-moz-)
+ 3.webkit:苹果&谷歌(-webkit-)
+ 4.Blink：谷歌&欧鹏
## 清除浮动
+ 1.在最后一个标签后面，添加一个空的div，给其设置clear:both；
+ 2. 给父元素添加clearfix类名：
  + clearfix:after{content=" ";display:block,clear:both;fint-szie:0;visibility:hidden;overflow:hidden;}
## display none 和 visibility hidden区别？
+ 两者都是用于元素的隐藏
+ display: none隐藏后的元素不占据任何空间；而visibility: hidden隐藏后的元素空间依旧保留 

# 三、 Vue
## vue的理解：
+ 是JS渐进式的框架；由浅入深、由简单到复杂；它的代码体积小，基于虚拟DOM，数据双向绑定；

+ 它可以把一个页面分成多个组件，当其他页面有类似功能时可以封装组件进行复用；

  ##vue中 v-for加 key的作用 

  ​	简单来说，当在列表循环中使用key时，需要使用key来给每个节点做一个唯一标识，diff算法就可以正确的识别此节点，找到正确的位置直接操作节点，尽可能地进行重用元素，key的作用主要是为了高效的更新虚拟DOM。
## v-if和v-show区别

+ v-show是通过display:none来实现隐藏

+ v-if是通过将元素从dom移除来实现隐藏

+ \1. v-if 条件为假时, 条件模板块不会进行编译解析, 也就是不创建真实DOM结构, 切换为真是创建一个新的真实DOM结构显示。

  \2. v-show在条件为假时, 条件模板块也会进行编译解析, 也就是会创建真实DOM结构, 只是通过display为none不显示, 当切换为真时, 只是通过去掉display的none值来显示出来, 不需要重新创建真实DOM结构。

  \3. 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则更适用于需要非常频繁切换条件的场景。
## computed 和 watch 的区别和运用的场景？

+ computed是计算属性 而 watch是监听属性

+ computed具有缓存功能 而 watch不支持缓存

+ computed不支持异步 而 watch支持异步

+ computed是通过多个数据来影响一个数据 而 watch是通过一个数据来影响多个数据

+ \1. **computed**： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

  \2. **watch**： 更多的是「观察/监视」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

  **3. 运用场景：**

  1). 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

  2). 当我们需要在数据变化时执行异步( 如发送ajax请求 )时，应该使用 watch。
##  keep-alive 的了解

keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：

- 一般结合路由一起使用，用于缓存路由组件；

-  提供 include 和 exclude 属性，两者都支持字符串和正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；

-  对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件离开时，触发钩子函数 deactivated。

## 组件中 data 为什么是一个函数

- 如果组件中的data选项是对象，那这个组件的每个实例都是通过配置的data属性得到的， 那此组件的多个标签实例data共用一个data数据对象, 一旦有一个组件对象改变了data中的数据， 其它组件对象界面也会更新

- 如果组件中 data 选项是一个函数，那每个组件对象都是通过执行配置的data函数得到的data数据对象， 那此组件的多个组件对象的data都不是同一个对象，一个组件对象修改其data内数据， 其它组件对象不会更新，因为data中的数据没有变化。

## 什么阶段才能访问操作DOM

在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM，一般通过ref来得到DOM对象进而做相应的操作。

## vue的生命周期
+ vue的生命周期有11个，常用的有8个；分别是

+ ###创建阶段：

  ####响应式数据劫持就发生在这个阶段，对data选项进行遍历，使用objec.defineProperty()对所有的声明试遍历进行劫持，加getter和setter钩子函数,并添加到当前实例的this上

+ beforeCreate:在组件被实例化之后，事件配置之前；此时el和数据对象data都是undefined,还没有初始化；

+ created：数据和方法初始化完成，但el属性还没有,没挂载到dom上 (主要左右：调用数据，调用方法，调用异步函数 )

+ ###挂载阶段：

  ####创建虚拟DOM，用真实数据替换成虚拟节点，完成试图最终渲染

  #### 虚拟DOM，是一个json对象，是根据真实DOM结构生成的，用于描述真实DOM结构，它保存内存中，给DOM更新提供了中间层，避免用户过渡地操作真实DOM，以提供Web性能 

+ beforeMount:模板在内存中编译完成，但还没渲染到页面上；vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点

+ mounted:vue实例挂载到真实dom上

+ ###更新阶段：

  ####当声明试变量发生变化时，生成新的DOM节点，执行diff运算找到数据前后的最小差异，通过watch来更新视图

  #### diff运算的工作流程：在挂载阶段，生成一个虚拟DOM，保存在内存中 ，当声明式数据发生变化时，Vue会生成一个新的虚拟DOM 使用diff(vm1, vm2)运算，找出两个虚拟DOM之间的最小差异，将其标记为脏节点 接着把脏节点patch到Watcher，使用真实DOM操作更新视图。 

+ beforeUpdate:组件更新之前，

+ updated: 组件更新完成

+ ### 销毁阶段：

  ####把自己及其子组件的事件处理器都卸载掉，指令解绑清除watch

+ beforeDestory:组件销毁前

+ 直接会父子组件之间断开连接、指令也会断开连接；响应式的失效；事件监听器的解绑；比如v-on

+ destroyed:组件销毁了

  ### 组件的一生：

+ 组件的加载渲染过程： 父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

+ 子组件更新过程： 父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated

+ 父组件更新过程： 父beforeUpdate -> 父updated

+ 销毁过程： 父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
## 在哪个生命周期内调用异步请求

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，用得较多的是created与mounted

-  created() 是发ajax请求最早的时机, 但无法读取初始界面(如果需要不选)

-  mounted() 是发ajax请求最晚的时机(在初始界面显示之后), 但它可以发请求前读取初始界面内容

## Vue组件之间是如何通信的?
+ 父组件通过prop属性向子组件传递数据
+ 子组件通过自定义事件(this.$emit) 向父组件传值
+ 组件间通过ref进行通信
+ 组件间还可以通过事件总线的方式进行通信

## vue插槽是什么 

插槽就是子组件中的提供给父组件使用的一个占位符，用<slot></slot> 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的<slot></slot>标签。 

## vue怎么实现双向绑定(v-model)
+ Vue的双向数据绑定是通过由数据劫持结合发布者订阅模式来实现的；
+ 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作
+ 通过Observer来监听自己的model数据变化，通过解析器Compile来解析编译模板指令，最终利用观察者Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化--->视图更新
+ 在初始化vue实例时，遍历data这个对象，给每个键值对利用Object.definedProperty对data的键值新增get和set方法，利用事件监听DOM的机制实现视图-->数据的改变
+ 实现的步骤：1.实现一个监听这Oberver来劫持并监听所有的属性，一旦属性有变化通知订阅者；2.实现一个订阅者watcher来接受属性变化的通知并执行相应的方法，从而更新视图；3.实现一个解析器compile，可以扫描每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者；达到数据更新-->视图更新；
+ 总结：我们在data中的数据是不具备响应式原理的，vue中通过object.defineProperty进行劫持数据，然后放在当前实例中，当data中的数据发生改变时，就会触发setter方法，setter就会通知watcher，watcher的作用就是用来更新视图，近而生成新的DOM树 

## Vue 是如何实现数据绑定的

Vue 主要通过以下 4 个步骤来实现数据绑定的：

1. **实现一个监听器 Observer**：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

2. **实现一个解析器 Compile**：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

3. **实现一个订阅者 Watcher**：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

4. **实现一个订阅器 Dep**：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

## Vue 中的 key 的理解

**1. 虚拟DOM的key的作用?** 

1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用   

2). 详细的说: 当列表数组中的数据发生变化生成新的虚拟DOM后, React进行新旧虚拟DOM的diff比较     

● key没有变       

 item数据没变, 直接使用原来的真实DOM       

 item数据变了, 对原来的真实DOM进行数据更新     

● key变了       

销毁原来的真实DOM, 根据item数据创建新的真实DOM显示(即使item数据没有变)  

**2. key为index的问题**   

1). 添加/删除/排序 => 产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低   

 2). 如果item界面还有输入框 => 产生错误的真实DOM更新 ==> 界面有问题   

注意: 如果不存在添加/删除/排序操作, 用index没有问题  

**3. 解决:**   

 使用item数据的标识数据作为key, 比如id属性值

## NextTick 原理分析
+ NextTick可以将回调延迟到下次DOM更新循环之后执行
## vue的路由
+即通过vue的路由允许我们通过不同的URL访问不同的内容
## 动态路由
+ 一般用于从一个页面到另一个页面中传递参数使用；
+ 即在path属性上加/:id，可以通过$route.params接收
## 如何改变URL?
+ 声明式路由导航：使用vue-router内置的<router-link> 组件来实现。
+ 编程式路由导航：使用 路由api【$router.push()/replace()/back()】来实现页面跳转。
+ 普通跳转，涉及到业务逻辑的用编程式路由导航
## hash模式和history模式
+ hash路由：表现上有#,上线后刷新页面没有报错，location.href 锚点技术来实现跳转
+ history路由：表现上没有#,上线刷新后页面可能会报404错误，要求后端进行重定向，是使用 history.pushState 实现跳转

## router-link

- router-link是vue-router内置组件
- 作用：用于改变url
- tag表示把router-link渲染成什么HTML元素，默认a标签
- to，表示我被点击时跳转到哪里去
- exact-active-class表示我被匹配成功，用哪些class类名来显示高亮样式

## router 和route的区别
+ $route 是路由信息对象，每一个路由都会有一个route对象，包含path,params,hash,query,fullPath,matched,name等路由信息属性。
+ $router是VueRouter的实例，包含了路由跳转的方法、钩子函数等。
## 路由懒加载    
+ 是一种性能优化方案，可以理解为导入组件的一种方式
+ 可以这么理解，只需要访问一个页面时，不需要将所有的组件都加载进来，可以使用路由懒加载，需要哪个页面就加载哪个页面；它的原理是：webpack代码分割功能和异步组件的特点来实现
+ 只有触发对应的链接时才编译相对应的组件 
## vue状态管理
+ 状态管理可以解决组件之间的数据共享、实现数据缓存
+ Vuex是vue全家桶中使用最流利的状态管理工具、一个专门为Vue.js应用程序开发的状态管理模式
+ 状态管理工具在vue项目架构中是可选的，但从项目长远发展角度来看，最好还是使用
## vuex的五大概念
+ State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。

  2). Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。

  3). Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。

  4). Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。

  5). Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

+ getters: 相当于组件的计算属性，与state相关，当它所关系的state变量发生变化时，会自动计算

+ mutations:Vuex中专门用于更新state

+ actions: 专门用于与后端api打交道

+ mudules:分模块，将不同的业务模块区分出来，使代码更加优雅
## vuex流程
+ 可以简单理解为Vue component触发事件，通过Action调后端数据，将后端回传的数据通过Mutations更新state，state将数据渲染到component中
+ 我们将需要共享的数据放在state中，页面组件通过dispath一个方法到actions中，actions是一个异步行为，用于调取后端数据，然后再commit一个方法给mutations,mustations的作用就是用来修改state中的数据，数据发生变化页面组件将自动更新
## vue 是怎么识别数据改变然后操作虚拟dom改变
+ 获取监听变化后生成的虚拟树节点
+ 与上一次虚拟DOM节点树进行比较
+ 找到差异部分，渲染到真实的DOM节点上
+ 更新视图
## 浅谈vue 的虚拟dom
+虚拟DOM的由来：JS是解析引擎的、页面渲染是渲染引擎的、两者之间的通信是通过DOM操作进行的，这样会消耗很多性能。虚拟DOM的诞生就是为了提高页面渲染性能
+ vue的虚拟DOM：Vue中有模板解析的函数、可以对html进行解析编译、从而转变成渲染函数，渲染函数执行后就变成了虚拟DOM节点树。当虚拟节点准备映射到视图的时候，为了避免额外的性能开销，会先和上一次的虚拟DOM节点树进行比较，然后只渲染不同的部分到视图中。
+ 虚拟DOM保存在内存中、在creact之前生成
## 虚拟 DOM 实现原理

虚拟 DOM 的简单实现原理主要包括以下 3 部分：

- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；

- diff 算法 — 比较两棵虚拟 DOM 树的差异；

- pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

## vue优化
+ 不要在模板里面写过多表达式
+ 循环调用子组件时添加key
+ 频繁切换的使用v-show，不频繁切换v-if
+ 尽量少用float，可以用flex
+ 按需加载需要的组件

## 路由守卫
+ 它的作用：阻止未登录用户进入需要权限的界面
+ router.beforeEach((to,from,next)=>{})来实现的
## {{}}一闪而过解决方法
+ 可以给{{}}外层添加一个div,里面写v-clock指令<div v-clock>，再通过css样式、display：none隐藏
## 直接给一个数组项赋值，Vue 能检测到变化吗

1. **问题分析**

由于Vue并没有给每个元素的下标属性添加监视，Vue 不能检测到直接通过下标设置新的元素值。也就是执行vm.items[indexOfItem] = newValue时，Vue检测不到变化，界面就无法更新。

2. **解决办法一：**

1). 使用数组的splice方法 （比较方便易懂， 推荐使用）

2). 原理： Vue重写了数组一系列更新元素的方法， 在更新元素后就会去更新界面

3. **解决办法二：**

1). 使用Vue.set()或vm.$set()

2). 原理：方法内部设置好元素数据后，就会去更新界面

## vue中如何实现多页面
+ 多个页面中挂载多个根组件就可以啦；
## SPA 单页面的理解，它的优缺点分别是什么

SPA（ single page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

1. **优点：**

1). 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；

2). 基于上面一点，SPA 相对对服务器压力小；

3). 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

2. **缺点：**

1). 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；

2). 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；

3). SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

# 四、React
## 1.jsx的理解
+ JSX是React官方推荐的一种语法糖；在React开发中不是必选的，可以不用，但不用就比较麻烦；
+ JSX实际上是变量、是对象、是React元素；JSX使用时必须要引入React；JSX中可以使用表达式，但要使用{}包裹；JSX可以嵌套；默认可以防注入攻击；可以复用
+ 在React开发中，推荐使用JSX，使用JSX可以使代码更加优雅，便于维护；
+ 它是 JavaScript XML
+ 它是 JS 的一种语法扩展（语法糖）
+ jsx不是必须要使用的，它只是React推荐使用的一种语法格式，因为使用JSX代码更加优雅、更容易维护

## 2.在react中有几种组件创建方式
+ 使用ES5API：reactCreatElement创建
+ 使用class关键字创建类组件 
+ 使用ES5function函数或ES6箭头函数来创建无状态组件
## 3.无状态组件和类组件
+ 类组件是使用class关键字来定义组件；它的特点是有state,有生命周期，有上下文、ref、this等特性；和无状态组件相比性能比较差
+ 用function关键字或箭头函数定义的组件；由于它没有state，被称为无状态组件；没有生命周期，没有上下文，this,ref等特性；与类组件相比，性能更高；

## 4.sate、setState异步特性、虚拟DOM
+ setState是React中专门用于更新vm，触发diff运算，更新视图的
+ setState默认是异步的，但在定时器中却是同步的；
+ 当有多个setState执行时，React会将其自动合并，只执行一次diff运算，一次视图更新

## 5.生命周期整个流程（321）

#### 挂载

当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：

- [**`constructor()`**](https://zh-hans.reactjs.org/docs/react-component.html#constructor) 

  加载的时候调用一次，可以初始化state

- [**`render()`**](https://zh-hans.reactjs.org/docs/react-component.html#render)

  react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行

- [**`componentDidMount()`**](https://zh-hans.reactjs.org/docs/react-component.html#componentdidmount)

  组件渲染之后调用，只调用一次

#### 更新

当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)

  组件接收到新的props或者state时调用，return true就会更新dom（使用diff算法更新），return false能阻止更新（不调用render）

- [**`render()`**](https://zh-hans.reactjs.org/docs/react-component.html#render)

- [**`componentDidUpdate()`**](https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate)

  组件加载时不调用，组件更新完成后调用

#### 卸载

当组件从 DOM 中移除时会调用如下方法：

- [**`componentWillUnmount()`**](

+ react生命周期分为三个阶段：装载阶段、更新阶段、销毁阶段。在装载阶段常用的生命周期有三个：counstructor,render,componentDidMount;在更新阶段常用的有两个：render 和 componentDidUpdate，shouldComponentUpdate;在销毁阶段有一个：componentWillUnmount
+ 更新阶段React做了什么？:更新阶段setState触发state进行更新；首先生成一个虚拟DOM，这时候内存中有两个虚拟DOM;接着 diff 运算对这两个虚拟DOM进行遍历，找出变化最小的节点然后标记出来变成脏节点；最后patch给其他的，执行真实的DOM操作
+ shouldComponentUpdate:这是一个开关，用于性能优化，我们可以精准控制某些state变量发生时不更新视图，要求一定有返回值，返回值一定是布尔值。接收两个参数，
## 6.虚拟DOM

什么是虚拟dom
用js模拟一颗dom树,放在浏览器内存中.当你要变更时,虚拟dom使用diff算法进行新旧虚拟dom的比较,将变更放到变更队列中,

反应到实际的dom树,减少了dom操作.

虚拟DOM将DOM树转换成一个JS对象树,diff算法逐层比较,删除,添加操作,但是,如果有多个相同的元素,可能会浪费性能,所以,react和vue-for引入key值进行区分.

优点：

- 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
- 
- 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
- 
- 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点:

- 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
  首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。

怎么工作

- 当数据发生变化，比如setState时，会引起组件重新渲染，整个UI都会以virtual dom的形式重新渲染
- 然后收集差异也就是diff新的virtual dom和老的virtual dom的差异
- 最后把差异队列里的差异，比如增加节点、删除节点、移动节点更新到真实的DOM上

# 7.虚拟dom和真实dom的区别

<img src="C:\Users\Administrator\Desktop\面试题1\DOM区别.png" alt="DOM区别" style="zoom:60%;" />

- 虚拟DOM不会进行排版与重绘操作
- 操作真实DOM中，会触发页面的回流与重绘，
   而这两个东西是非常耗费性能的。因此我们越少操作真实dom就越好
- 虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗
- 真实DOM频繁排版与重绘的效率是相当低的
- 虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）
- 一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟DOM，关键看框架是否频繁会引发大面积的DOM操作。 虚拟DOM是由js实现的避免DOM树频繁更新，通过js的对象模拟DOM中的节点，然后通过特定的render方法将它渲染成真实的节点，数据更新时，渲染得到新的 Virtual DOM，与上一次得到的 Virtual DOM 进行 diff，得到所有需要在 DOM 上进行的变更，然后在 patch 过程中应用到 DOM 上实现UI的同步更新

 ## 7.React中Key的作用

### 1、key的作用

react中的key属性，它是一个特殊的属性，它是出现不是给开发者用的，而是给React自己使用，有了key属性后，就可以与组件建立了一种对应关系，简单说，react利用key来识别组件，他是一种身份标识，就像每个人有一个身份证来做辨识一样。每个key 对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建

 key不是用来提升react的性能的，不过用好key对性能是有帮助的。

key值相同

如果两个元素是相同的key，且满足第一点元素类型相同， 若元素属性有所变化，则React只更新组件对应的属性，这种情况下，性能开销会相对较小

key值不同

在render函数执行的时候，新旧两个虚拟DOM会进行对比，如果两个元素有不同的key，那么在前后两次渲染中就会被认为是不同的元素，这时候旧的那个元素会被unmount，新的元素会被mount

### 2、key的使用场景

在项目开发中，key属性的使用场景最多的还是由数组动态创建的子组件的情况，需要为每个子组件添加唯一的key属性值

另外，还有一种比较常见的场景：为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。

### 3、key的最佳实践

index作为key是一种反模式
 在list数组中，用key来标识数组创建子组件时，若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。

但是，若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。
 所以在做数组新增元素、删除元素或者排序的时候不要使用index作为key，可以用后端提供过来的唯一值 ID

得出结论
 在数组中生成的每项都要有key属性，并且key的值是一个永久且唯一的值，即稳定唯一，所以**key的值要稳定唯一**，但不能使用random来生成key的值
 Math.random随机生成，虽然能够保持其唯一性，但是它的值是随机而不是稳定的，在数组动态改变时会导致数组元素中的每项都重新销毁然后重新创建，有一定的性能开销；另外可能导致一些意想不到的问题出现。
 所以：

> key的值要保持稳定且唯一，不能使用random来生成key的值。

### 4、key的其他注意事项

key属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。

key值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一

不仅仅在数组生成组件上，其他地方也可以使用key，主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。

## 8.React性能优化

PureComponent 的使用场景

PureComponent 和 Component 的区别是，PureComponent 自带 shouldComponentUpdate 生命周期函数，会对传入的props进行浅比较。

PureComponent 和 immutable.js库 做结合，完美的解决react的性能问题。

## 9.什么是受控表单，什么是非受控表单
+ 在React中表单是单向绑定的，要想让视图变化，state数据必须改变
+ 受控表单指表单的 value/checked由 state 完全控制
+ 非受控表单指表单的value和checked 不受 state 完全控制
## 10.React的传值方式：

父子传值：

1.向下传值--父组件向子组件传值
父组件通过props传递一个不是方法的数据，给子组件；

2.向上传值--子组件向父组件传值
父组件通过props向子组件传入一个方法，子组件在通过调用该方法，并将数据以参数的形式传给父组件，父组件可以在该方法中对传入的数据进行处理；

3.兄弟传值

兄弟间传值由于没有任何嵌套关系，所以结合上述两种情况，很容易想到将需要共享的值和方法使用上述的方法传至共同的父组件，由父组件再传入。

建议使用react-redux或者dva框架

+ 父组件向子组件传值是通过props属性进行传值
+ 子组件向父组件是通过自定义事件来传值
+ 兄弟组件之间的传值是通过状态提升，将需要共享的数据传到父组件去进行数据共享；

## 11.组件的复用是组合还是继承？
+ 使用的是组合：基于props来使用，props.childen的使用，props自定义的属性
## 12.上下文是什么，解决什么问题
+ React中有个API：creatContext
+ 在根组件上注入数据，然后组件树上所有组件节点都可以访问
+ 特点：数据只能单向传递，即从根组件向后代组件传递
+ 状态管理就是借助上下文来实现数据的传递
## 13.高阶组件：如何理解，做过啥事？
+ 是一种基于React组合特性而得来的一种设计模式、软件开发经验
+ 它的作用是React业务逻辑复用的一种方案
+ 它也被称为高阶函数、纯函数、容器组件
+ 高阶组件是一个以组件为参数并返回一个新组件的函数。
+ 使用高阶组件做过粗细粒度的权限管理；不同用户进入同一个界面，显示的东西有所不同；
+  如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC
## 14.类型检查：prop-Types
+ 验证Props的数据类型
+ 安装的第三方包：prop-type

## 15.Hook
+ 是react 16.8提供的一套API,用于解决函数式组件中缺少类组件相关特性的问题，我常用的有usesate和useEffect;
+ useState:定义一个声明式变量,当变量变化时视图自动更新
+ useEffect：相当于react的生命周期；第一个参数相当于componentDidMount：return相当于componentWillUnmount;第二个参数是伪数组，相当于componentDidUpdate；useEffect可以使用多次
+ useEffect是一个函数，有两个参数一个是函数，一个是可选参数-数组，根据第二个参数中是否有变化，来判断是否执行第一个参数的函数,我们需要根据第二个参数来判断是否执行，而不是一直执行。所以我们还需要有一个判断逻辑去执行函数。
+ useref返回一个引用了DOM的对象。 返回的对象将在组件的整个生存期内持续存在。与 createRef 区别 createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。因此你可以在 useRef 对象上存放缓存的值，可以存储哪些不需要引起页面重新渲染的数据。
+ useContext跨组件共享数据的钩子函数。
## 16.react路由：react-router-dom
+ 使用的是第三方的路由：react-router-dom，需要安装使用
+ 用于编程式路由跳转，动态路由传递
+ 常用的组件有：HashRouter/BrowserRouter，Route,NavLink，Redirect,Switch等
+ 没有被Route组件直接包裹的React组件中，是没有路由API的。那怎么办呢?
  + 在类组件中，只能使用 withRouter 来解决问题:
  + 在无状态组件中，可以使用 withRouter，也可以使用 useHistory来解决问题。
+ withRouter 是一个高阶组件，让那些没有被Route组件直接包裹的React组件拥有路由API
+ useHistory 是ReactRouter提供的Hooks API，帮助我们在无状态组件中使用路由API
+ react-router：提供了router的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的api；
+ react-router-dom：提供了BrowserRouter、Route、Link等api，可以通过dom操作触发事件控制路由。
+ react-router-dom里包含了react-router的依赖
## 17.代码分割（路由懒加载）
+ 代码分割是性能优化的一种解决方案。比如我们的路由系统中有100个组件，我们在react项目启动时不需要对这100个组件都进行编译，只编译当前URL对应的组件，这就可以用到代码分割的功能；
+ webpack代码分割以及配合路由实现
## 18.状态管理
+ 状态就是数据，状态管理工具是用来对应用程序中数据进行科学的管理；最早出现状态管理思想是Flux,Flux只是一套数据流管理的指导思想、设计模式；常用的状态管理工具有mobox和redux；
## mobox
+ mobx用于定义store、mobx-react用于把mobx和react组件连接起来；借助了react的上下文和高阶组件
+ 
## 19.redux

设计理念

Redux是将整个应用状态存储到一个地方上称为**store**,里面保存着一个状态树**store tree**,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件，组件内部通过订阅**store**中的状态**state**来刷新自己的视图。

三大原则

- 1 唯一数据源

  整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中

- 2 保持只读状态

  state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象

- 3 数据改变只能通过纯函数来执行

  使用纯函数来执行修改，为了描述action如何改变state的，你需要编写reducers

## 20.调用 setState 之后发生了什么？

- \1. React 会将传入的参数对象与组件当前的状态合并产生了新的state

  \2. 生成新的虚拟DOM树  ==> render()

  \3. 计算出新树与老树的节点差异，然后做真实DOM的差异更新

## 21.区别React中的事件与原生的DOM事件

- \1. 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件封装为合成事件

  \2. React 并没有直接将事件附着到子元素上, 而是将事件绑定在了组件的根元素上(使用事件委托)

## 22.什么是上下文Context

- Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。

### redux-thunk
 + 解决异步actions，用于把一个异步的action转化成两个同步的action；
 + 比如我们要把后端数据放在store中，在组件中先发送一次空的action，通知调接口；调接口成功后，再把后端真实数据dispath()到store
### 三三原则
+ 第一个'三':方法：
  + createStore(combineReducers({aReducer,bReducer}),[iniiState],applyMiddleware(thunk))
    + creacteStore:是创建Store，要求必须要有reducer传入
    + combineReducer:用于把一个大的reducer切分成多个小的reducer
    + applyMiddleware:用于扩展redux功能，比如调接口，支持异步action转同步action
+ 第二个'三'：API:
  + Store:是redux的数据存储中心，他可以接收dispatch过来的action，把action分配给reducer进行处理，当store的数据再次发生变化时，视图自动更新
  + Reducer:是函数、纯函数；它用于处理store分配给自己的任务，处理数据，返回新Store
  + Action:是视图和store的纽带，它是被dispath到store中，action的固定格式是{type,payload}
+ 第三个'三'：store的三个特点：
  + Store是只读的，不能直接修改，建议使用深复制的方式生成新的store，在修改
  + Store是单一数据源
  + Store只能用纯函数来修饰
## 变量提升
+ 通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去
## vue和React区别
+ vue是尤雨溪写的、React是Fecebook写的
+ vue中的数据是双向绑定，而React是单向数据流
+ vue中有很多指令，React中没有那些指令
+ vue中的生命周期是固定的；而React中很多生命周期已经慢慢废弃
## 五、微信小程序

## 1.微信小程序登录流程

![小程序登录](C:\Users\Administrator\Desktop\面试题1\小程序登录.png)

+ 微信小程序登录涉及到三端：微信小程序端、后端、微信服务器端
+ 小程序端通过wx.login()获取code,通过wx.request()发送code到后端;后端经过一系列的处理后将3rd_session返回给小程序端，小程序端将3rd_sesion存入storage中；后续用户重新进入小程序，调用wx.checksession()，检测登录状态，如失效，则重新发起登录
+ code是临时凭证，随机字符串，有效期5分钟。
+ 后端拿到code，使用appid、app秘钥和code发送给微信官方服务器，微信官方服务器收到三个字段进行处理session_key+openid给后端。
+ session_key相当于token
+ openid是每一个用户在微信生态中唯一的编号，是唯一的，相当于身份证号码，永远不会改变
+ 后端会把openid存储在mysql数据库中
+ 后端把session_key给前端，前端把session_key存储在storage中
+ wx.request()发起业务请求，携带session_key
+ 后端收到session_key验证身份返回当前用户的雨业务数据

## 2.微信小程序支付流程

其实就是调用服务端 API，生成支付参数， 再调用微信 API， 调起支付， 用户支付成功/取消，直接调用回调处理，搞定 

## 3.小程序的生命周期函数

-  **onLoad**页面加载时触发。一个页面只会调用一次，可以在`onLoad` 的参数中获取打开当前页面路径中的参数
- **onShow()**页面显示/切入前台时触发
-  **onReady()**页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互，所有的声明式变量，动态数据渲染已经完成的时候
-  **onHide()**页面隐藏/切入后台时触发。 如 `navigateTo` 或底部 `tab` 切换到其他页面，小程序切入后台等
- **onUnload()**页面卸载时触发。如 `redirectTo 或 navigateBack` 到其他页面时
-  **onLaunch **跟组件的生命周期，初始化完成时触发（全局只触发一次）



## 4.小程序扫码

- 第1步，把一package的商品信息发送给后端（带token）

-  第2步，后端要根据package商品信息+appid+密钥等，生成支付加密字符串，返回给前端

- 第3步，前端收到支付加密字符串后，调用Tara.requestPayment({})完成最终支付

- 一.小程序调用登录接口获取code，传递给商户服务器用来获取用户的openID

  1.小程序调用wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。

  2.开发者服务器以code换取 用户唯一标识openid 和 会话密钥session_key。

  二.token的生成以及缓存

  三，调用统一下单接口，获取prepay_id,再次签名

  四，小程序获取五个参数后，鉴权调起支付

  1.下载微信JS-SDK：

  2.调用统一下单api

  3.再次签名



## 5.小程序地图

- 需要全局配置，在app.config.js配置用于获取地理授权permission字段(是一个对象)
- getSetting  在onshow写
- 用户拒绝之后，想要重新获取定位。再次获取同意定位。
- 需要在其他页面使用button按钮，openSetting点击打开一个微信内置的授权页面，同意定位授权
- 如果没有授权就显示，授权就不显示按钮
- 当用户授权了地理定位，就获取经纬度getLocation
- 获取经纬度之后，在地图map上显示。只是简单展示位置
- 导航去这里功能。openLocation打开微信内置地图，并显示指定的位置。



# 六、混合app

- IOS/Andriod原生app +  H5
- 利用webview src=‘’链接到H5页面    嵌套的不是代码，嵌套的是前端H5代码打包上线之后的url链接，如果没有做特殊处理，放在哪里都可以访问，做特殊处理之后，只可以再app里面访问。

# JavaScript动画和CSS3动画的区别

- JS动画（逐帧动画）
　　首先，在js动画是逐帧动画，是在时间帧上逐帧绘制帧内容，由于是一帧一帧的话，所以他的可操作性很高，几乎可以完成任何你想要的动画形式。但是由于逐帧动画的帧序列内容不一样，会增加制作负担，且资源占有比较大。但它的优势也很明显：因为它相似与电影播放模式，很适合于表演很细腻的动画，如3D效果、人物或动物急剧转身等等效果。但是，如果帧率过低的话，会帧与帧之间的过渡很可能会不自然、不连贯。

　　js是单线程的脚本语言，当js在浏览器主线程运行时，主线程还有其他需要运行的js脚本、样式、计算、布局、交互等一系列任务，对其干扰线程可能出现阻塞，造成丢帧的情况。

　　其次，js在做动画的时候，其复杂度是高于css3的，需要考虑一些计算，操作等方便问题。

　　但是正是由于js对动画的操作复杂度比较高，能对动画有一个比较好的控制，如开始、暂定、回放、终止、取帧等，可以很精确的做到。因此可以js可以通过操作DOM和BOM来做一些酷炫的动态效果，以及爆炸特效，且兼容性比较好。

- css3（补间动画）
　　制作方法简单方便。只需确定第一帧和最后一帧的关键位置即可，两个关键帧之间帧的内容由Flash自动生成，不需要人为处理。当然也可以多次添加关键帧的位置。

　　因为只设置几个关键帧的位置，所以在进行动画控制的时候时比较弱的。不能够在半路暂停动画，或者在动画过程中不能对其进行一些操作等。

　　css3在实现一些简单的滑动，翻转等特效的时候会很方便，但是想要做到一些酷炫的效果的时候，其操作往往可能会比js操作有更多的冗余。

　　css3在做动画的时候，浏览器可以对其进行一些优化，会比js使用更少的占用cpu资源，但是效果足够流畅。

结论
　　如果动画只是一些简单的状态切换，滑动等效果，不需要中间的控制过程，css3是比较好的选择，它直接在css文件中就可以实现，并不需要引入太多的js库。而你想做一些复杂的客户端界面，开发一个复杂ui的app，实现一个复杂纹理动画等，需要对页面进行精准的控制计算，js是不错的选择。



# 自我介绍

面试官，你好。我叫叶丽娟，很荣幸能有这个面试机会，今天想应聘的是贵公司的前段工程师岗位，最近做的react相关的项目，最后我希望自己可以有机会加入贵公司的团队,学习更多技术和经验。以上就是我的自我介绍。谢谢!



蜂羽云科技有限公司   广州市 番禺区 奥园城市天地8区 2栋1006-1007

瑞志信息科技有限公司    广州市天河区宦溪西路22号317房（仅限办公）


